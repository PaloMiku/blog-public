const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./DkNHrg89.js","./Dhc2QW2m.js","./wC-D7y6G.js","./entry.BiVjzasw.css","./vhikiTxS.js"])))=>i.map(i=>d[i]);
import{z as dt,G as O,bk as st,Q as lt,e as b,w as $,h as A,g as z,n as xt,N,t as zt,L as y,Z as bt,_ as ht,A as kt,y as Ft,D as Mt,bl as Ct,bm as Tt,r as W,aw as Vt,aj as Lt,ad as B,ae as nt,aC as Ot,d as T,bn as At,f as D,a2 as J,I as Et,J as Dt,aM as it,M as Pt,K as jt,a4 as Nt,F as ot,P as $t,a3 as Rt,bo as Wt,T as Bt,b as Jt}from"./wC-D7y6G.js";import Ut from"./BUuREKMa.js";import"./fHq1OrIJ.js";const Qt={class:"title text-creative"},Kt=["innerHTML"],qt=["innerHTML"],Ht=dt({__name:"SearchItem",props:{title:{},content:{},titles:{},level:{},id:{},terms:{},queryTerms:{},score:{},match:{}},setup(i){const t=i,e=O(()=>[...t.titles??[],t.title].join(" > ")),s=O(()=>st(e.value,t.queryTerms)),n=O(()=>st(t.content??"",t.queryTerms));return(o,r)=>{const c=Ut,u=bt;return b(),lt(u,{to:i.id,class:"search-item"},{default:$(()=>[A("div",Qt,[z(c,{round:"",class:xt({primary:i.level===1})},{default:$(()=>[N(zt(i.level===1?"文章":`H${i.level}`),1)]),_:1},8,["class"]),A("span",{innerHTML:y(s)},null,8,Kt)]),A("p",{class:"content",innerHTML:y(n)},null,8,qt)]),_:1},8,["to"])}}}),Gt=Object.assign(ht(Ht,[["__scopeId","data-v-60b89260"]]),{__name:"PopoverSearchItem"}),Yt="ENTRIES",ft="KEYS",mt="VALUES",S="";class U{constructor(t,e){const s=t._tree,n=Array.from(s.keys());this.set=t,this._type=e,this._path=n.length>0?[{node:s,keys:n}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:e}=V(this._path);if(V(e)===S)return{done:!1,value:this.result()};const s=t.get(V(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=V(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>V(t)).filter(t=>t!==S).join("")}value(){return V(this._path).node.get(S)}result(){switch(this._type){case mt:return this.value();case ft:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const V=i=>i[i.length-1],Zt=(i,t,e)=>{const s=new Map;if(t===void 0)return s;const n=t.length+1,o=n+e,r=new Uint8Array(o*n).fill(e+1);for(let c=0;c<n;++c)r[c]=c;for(let c=1;c<o;++c)r[c*n]=c;return gt(i,t,e,s,r,1,n,""),s},gt=(i,t,e,s,n,o,r,c)=>{const u=o*r;t:for(const a of i.keys())if(a===S){const d=n[u-1];d<=e&&s.set(c,[i.get(a),d])}else{let d=o;for(let h=0;h<a.length;++h,++d){const l=a[h],f=r*d,g=f-r;let p=n[f];const _=Math.max(0,d-e-1),w=Math.min(r-1,d+e);for(let I=_;I<w;++I){const M=l!==t[I],F=n[g+I]+ +M,C=n[g+I+1]+1,v=n[f+I]+1,m=n[f+I+1]=Math.min(F,C,v);m<p&&(p=m)}if(p>e)continue t}gt(i.get(a),t,e,s,n,d,r,c+a)}};class k{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=R(this._tree,t.slice(this._prefix.length));if(e===void 0){const[n,o]=X(s);for(const r of n.keys())if(r!==S&&r.startsWith(o)){const c=new Map;return c.set(r.slice(o.length),n.get(r)),new k(c,t)}}return new k(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,Xt(this._tree,t)}entries(){return new U(this,Yt)}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return Zt(this._tree,t,e)}get(t){const e=G(this._tree,t);return e!==void 0?e.get(S):void 0}has(t){const e=G(this._tree,t);return e!==void 0&&e.has(S)}keys(){return new U(this,ft)}set(t,e){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,Q(this._tree,t).set(S,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Q(this._tree,t);return s.set(S,e(s.get(S))),this}fetch(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Q(this._tree,t);let n=s.get(S);return n===void 0&&s.set(S,n=e()),n}values(){return new U(this,mt)}[Symbol.iterator](){return this.entries()}static from(t){const e=new k;for(const[s,n]of t)e.set(s,n);return e}static fromObject(t){return k.from(Object.entries(t))}}const R=(i,t,e=[])=>{if(t.length===0||i==null)return[i,e];for(const s of i.keys())if(s!==S&&t.startsWith(s))return e.push([i,s]),R(i.get(s),t.slice(s.length),e);return e.push([i,t]),R(void 0,"",e)},G=(i,t)=>{if(t.length===0||i==null)return i;for(const e of i.keys())if(e!==S&&t.startsWith(e))return G(i.get(e),t.slice(e.length))},Q=(i,t)=>{const e=t.length;t:for(let s=0;i&&s<e;){for(const o of i.keys())if(o!==S&&t[s]===o[0]){const r=Math.min(e-s,o.length);let c=1;for(;c<r&&t[s+c]===o[c];)++c;const u=i.get(o);if(c===o.length)i=u;else{const a=new Map;a.set(o.slice(c),u),i.set(t.slice(s,s+c),a),i.delete(o),i=a}s+=c;continue t}const n=new Map;return i.set(t.slice(s),n),n}return i},Xt=(i,t)=>{const[e,s]=R(i,t);if(e!==void 0){if(e.delete(S),e.size===0)_t(s);else if(e.size===1){const[n,o]=e.entries().next().value;pt(s,n,o)}}},_t=i=>{if(i.length===0)return;const[t,e]=X(i);if(t.delete(e),t.size===0)_t(i.slice(0,-1));else if(t.size===1){const[s,n]=t.entries().next().value;s!==S&&pt(i.slice(0,-1),s,n)}},pt=(i,t,e)=>{if(i.length===0)return;const[s,n]=X(i);s.set(n+t,e),s.delete(n)},X=i=>i[i.length-1],tt="or",wt="and",te="and_not";class L{constructor(t){if(t?.fields==null)throw new Error('MiniSearch: option "fields" must be provided');const e=t.autoVacuum==null||t.autoVacuum===!0?H:t.autoVacuum;this._options={...q,...t,autoVacuum:e,searchOptions:{...rt,...t.searchOptions||{}},autoSuggestOptions:{...oe,...t.autoSuggestOptions||{}}},this._index=new k,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=Z,this.addFields(this._options.fields)}add(t){const{extractField:e,stringifyField:s,tokenize:n,processTerm:o,fields:r,idField:c}=this._options,u=e(t,c);if(u==null)throw new Error(`MiniSearch: document does not have ID field "${c}"`);if(this._idToShortId.has(u))throw new Error(`MiniSearch: duplicate ID ${u}`);const a=this.addDocumentId(u);this.saveStoredFields(a,t);for(const d of r){const h=e(t,d);if(h==null)continue;const l=n(s(h,d),d),f=this._fieldIds[d],g=new Set(l).size;this.addFieldLength(a,f,this._documentCount-1,g);for(const p of l){const _=o(p,d);if(Array.isArray(_))for(const w of _)this.addTerm(f,a,w);else _&&this.addTerm(f,a,_)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,n={chunk:[],promise:Promise.resolve()},{chunk:o,promise:r}=t.reduce(({chunk:c,promise:u},a,d)=>(c.push(a),(d+1)%s===0?{chunk:[],promise:u.then(()=>new Promise(h=>setTimeout(h,0))).then(()=>this.addAll(c))}:{chunk:c,promise:u}),n);return r.then(()=>this.addAll(o))}remove(t){const{tokenize:e,processTerm:s,extractField:n,stringifyField:o,fields:r,idField:c}=this._options,u=n(t,c);if(u==null)throw new Error(`MiniSearch: document does not have ID field "${c}"`);const a=this._idToShortId.get(u);if(a==null)throw new Error(`MiniSearch: cannot remove document with ID ${u}: it is not in the index`);for(const d of r){const h=n(t,d);if(h==null)continue;const l=e(o(h,d),d),f=this._fieldIds[d],g=new Set(l).size;this.removeFieldLength(a,f,this._documentCount,g);for(const p of l){const _=s(p,d);if(Array.isArray(_))for(const w of _)this.removeTerm(f,a,w);else _&&this.removeTerm(f,a,_)}}this._storedFields.delete(a),this._documentIds.delete(a),this._idToShortId.delete(u),this._fieldLength.delete(a),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new k,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(e==null)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((s,n)=>{this.removeFieldLength(e,n,this._documentCount,s)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:n}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:n},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of t)this.discard(s)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,n=s(t,e);this.discard(n),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=Z,this.performVacuuming(t,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const s=this._dirtCount;if(this.vacuumConditionsMet(e)){const n=t.batchSize||Y.batchSize,o=t.batchWait||Y.batchWait;let r=1;for(const[c,u]of this._index){for(const[a,d]of u)for(const[h]of d)this._documentIds.has(h)||(d.size<=1?u.delete(a):d.delete(h));this._index.get(c).size===0&&this._index.delete(c),r%n===0&&await new Promise(a=>setTimeout(a,o)),r+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(t==null)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||H.minDirtCount,s=s||H.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,n={...s,...e},o=this.executeQuery(t,e),r=[];for(const[c,{score:u,terms:a,match:d}]of o){const h=a.length||1,l={id:this._documentIds.get(c),score:u*h,terms:Object.keys(d),queryTerms:a,match:d};Object.assign(l,this._storedFields.get(c)),(n.filter==null||n.filter(l))&&r.push(l)}return t===L.wildcard&&n.boostDocument==null||r.sort(ut),r}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const s=new Map;for(const{score:o,terms:r}of this.search(t,e)){const c=r.join(" "),u=s.get(c);u!=null?(u.score+=o,u.count+=1):s.set(c,{score:o,terms:r,count:1})}const n=[];for(const[o,{score:r,terms:c,count:u}]of s)n.push({suggestion:o,terms:c,score:r/u});return n.sort(ut),n}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(q.hasOwnProperty(t))return K(q,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:n,fieldLength:o,storedFields:r,serializationVersion:c}=t,u=this.instantiateMiniSearch(t,e);u._documentIds=P(n),u._fieldLength=P(o),u._storedFields=P(r);for(const[a,d]of u._documentIds)u._idToShortId.set(d,a);for(const[a,d]of s){const h=new Map;for(const l of Object.keys(d)){let f=d[l];c===1&&(f=f.ds),h.set(parseInt(l,10),P(f))}u._index.set(a,h)}return u}static async loadJSAsync(t,e){const{index:s,documentIds:n,fieldLength:o,storedFields:r,serializationVersion:c}=t,u=this.instantiateMiniSearch(t,e);u._documentIds=await j(n),u._fieldLength=await j(o),u._storedFields=await j(r);for(const[d,h]of u._documentIds)u._idToShortId.set(h,d);let a=0;for(const[d,h]of s){const l=new Map;for(const f of Object.keys(h)){let g=h[f];c===1&&(g=g.ds),l.set(parseInt(f,10),await j(g))}++a%1e3===0&&await vt(0),u._index.set(d,l)}return u}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:n,fieldIds:o,averageFieldLength:r,dirtCount:c,serializationVersion:u}=t;if(u!==1&&u!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const a=new L(e);return a._documentCount=s,a._nextId=n,a._idToShortId=new Map,a._fieldIds=o,a._avgFieldLength=r,a._dirtCount=c||0,a._index=new k,a}executeQuery(t,e={}){if(t===L.wildcard)return this.executeWildcardQuery(e);if(typeof t!="string"){const l={...e,...t,queries:void 0},f=t.queries.map(g=>this.executeQuery(g,l));return this.combineResults(f,l.combineWith)}const{tokenize:s,processTerm:n,searchOptions:o}=this._options,r={tokenize:s,processTerm:n,...o,...e},{tokenize:c,processTerm:u}=r,h=c(t).flatMap(l=>u(l)).filter(l=>!!l).map(ie(r)).map(l=>this.executeQuerySpec(l,r));return this.combineResults(h,r.combineWith)}executeQuerySpec(t,e){const s={...this._options.searchOptions,...e},n=(s.fields||this._options.fields).reduce((p,_)=>({...p,[_]:K(s.boost,_)||1}),{}),{boostDocument:o,weights:r,maxFuzzy:c,bm25:u}=s,{fuzzy:a,prefix:d}={...rt.weights,...r},h=this._index.get(t.term),l=this.termResults(t.term,t.term,1,t.termBoost,h,n,o,u);let f,g;if(t.prefix&&(f=this._index.atPrefix(t.term)),t.fuzzy){const p=t.fuzzy===!0?.2:t.fuzzy,_=p<1?Math.min(c,Math.round(t.term.length*p)):p;_&&(g=this._index.fuzzyGet(t.term,_))}if(f)for(const[p,_]of f){const w=p.length-t.term.length;if(!w)continue;g?.delete(p);const I=d*p.length/(p.length+.3*w);this.termResults(t.term,p,I,t.termBoost,_,n,o,u,l)}if(g)for(const p of g.keys()){const[_,w]=g.get(p);if(!w)continue;const I=a*p.length/(p.length+w);this.termResults(t.term,p,I,t.termBoost,_,n,o,u,l)}return l}executeWildcardQuery(t){const e=new Map,s={...this._options.searchOptions,...t};for(const[n,o]of this._documentIds){const r=s.boostDocument?s.boostDocument(o,"",this._storedFields.get(n)):1;e.set(n,{score:r,terms:[],match:{}})}return e}combineResults(t,e=tt){if(t.length===0)return new Map;const s=e.toLowerCase(),n=ee[s];if(!n)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(n)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const n={};for(const[o,r]of s)n[o]=Object.fromEntries(r);t.push([e,n])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,n,o,r,c,u,a=new Map){if(o==null)return a;for(const d of Object.keys(r)){const h=r[d],l=this._fieldIds[d],f=o.get(l);if(f==null)continue;let g=f.size;const p=this._avgFieldLength[l];for(const _ of f.keys()){if(!this._documentIds.has(_)){this.removeTerm(l,_,e),g-=1;continue}const w=c?c(this._documentIds.get(_),e,this._storedFields.get(_)):1;if(!w)continue;const I=f.get(_),M=this._fieldLength.get(_)[l],F=ne(I,g,this._documentCount,M,p,u),C=s*n*h*w*F,v=a.get(_);if(v){v.score+=C,re(v.terms,t);const m=K(v.match,e);m?m.push(d):v.match[e]=[d]}else a.set(_,{score:C,terms:[t],match:{[e]:[d]}})}}return a}addTerm(t,e,s){const n=this._index.fetch(s,at);let o=n.get(t);if(o==null)o=new Map,o.set(e,1),n.set(t,o);else{const r=o.get(e);o.set(e,(r||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s)){this.warnDocumentChanged(e,t,s);return}const n=this._index.fetch(s,at),o=n.get(t);o==null||o.get(e)==null?this.warnDocumentChanged(e,t,s):o.get(e)<=1?o.size<=1?n.delete(t):o.delete(e):o.set(e,o.get(e)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const n of Object.keys(this._fieldIds))if(this._fieldIds[n]===e){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${n}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,n){let o=this._fieldLength.get(t);o==null&&this._fieldLength.set(t,o=[]),o[e]=n;const c=(this._avgFieldLength[e]||0)*s+n;this._avgFieldLength[e]=c/(s+1)}removeFieldLength(t,e,s,n){if(s===1){this._avgFieldLength[e]=0;return}const o=this._avgFieldLength[e]*s-n;this._avgFieldLength[e]=o/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:n}=this._options;if(s==null||s.length===0)return;let o=this._storedFields.get(t);o==null&&this._storedFields.set(t,o={});for(const r of s){const c=n(e,r);c!==void 0&&(o[r]=c)}}}L.wildcard=Symbol("*");const K=(i,t)=>Object.prototype.hasOwnProperty.call(i,t)?i[t]:void 0,ee={[tt]:(i,t)=>{for(const e of t.keys()){const s=i.get(e);if(s==null)i.set(e,t.get(e));else{const{score:n,terms:o,match:r}=t.get(e);s.score=s.score+n,s.match=Object.assign(s.match,r),ct(s.terms,o)}}return i},[wt]:(i,t)=>{const e=new Map;for(const s of t.keys()){const n=i.get(s);if(n==null)continue;const{score:o,terms:r,match:c}=t.get(s);ct(n.terms,r),e.set(s,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,c)})}return e},[te]:(i,t)=>{for(const e of t.keys())i.delete(e);return i}},se={k:1.2,b:.7,d:.5},ne=(i,t,e,s,n,o)=>{const{k:r,b:c,d:u}=o;return Math.log(1+(e-t+.5)/(t+.5))*(u+i*(r+1)/(i+r*(1-c+c*s/n)))},ie=i=>(t,e,s)=>{const n=typeof i.fuzzy=="function"?i.fuzzy(t,e,s):i.fuzzy||!1,o=typeof i.prefix=="function"?i.prefix(t,e,s):i.prefix===!0,r=typeof i.boostTerm=="function"?i.boostTerm(t,e,s):1;return{term:t,fuzzy:n,prefix:o,termBoost:r}},q={idField:"id",extractField:(i,t)=>i[t],stringifyField:(i,t)=>i.toString(),tokenize:i=>i.split(ce),processTerm:i=>i.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(i,t)=>{typeof console?.[i]=="function"&&console[i](t)},autoVacuum:!0},rt={combineWith:tt,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:se},oe={combineWith:wt,prefix:(i,t,e)=>t===e.length-1},Y={batchSize:1e3,batchWait:10},Z={minDirtFactor:.1,minDirtCount:20},H={...Y,...Z},re=(i,t)=>{i.includes(t)||i.push(t)},ct=(i,t)=>{for(const e of t)i.includes(e)||i.push(e)},ut=({score:i},{score:t})=>t-i,at=()=>new Map,P=i=>{const t=new Map;for(const e of Object.keys(i))t.set(parseInt(e,10),i[e]);return t},j=async i=>{const t=new Map;let e=0;for(const s of Object.keys(i))t.set(parseInt(s,10),i[s]),++e%1e3===0&&await vt(0);return t},vt=i=>new Promise(t=>setTimeout(t,i)),ce=/[\n\r\p{Z}\p{P}]+/u,ue={key:0,class:"blog-search"},ae={key:0,class:"no-result"},de=dt({__name:"Search",props:{show:{type:Boolean}},async setup(i){let t,e;const s=i,n=kt(),o=Ft(),r=Intl.Segmenter&&new Intl.Segmenter(o.language,{granularity:"word"}),{data:c,status:u}=([t,e]=Mt(()=>Ct("search",()=>Jt(()=>import("./DkNHrg89.js"),__vite__mapDeps([0,1,2,3,4]),import.meta.url).then(v=>(v.default||v)()))),t=await t,e(),t),a=new L({fields:["title","content"],storeFields:["title","titles","content","level"],searchOptions:{prefix:!0,fuzzy:.2,combineWith:"AND",boost:{title:3,titles:2}},processTerm:r?v=>Array.from(r.segment(v)).map(m=>m.segment.toLowerCase()):void 0}),d=Tt(),h=W(),{word:l,debouncedWord:f}=Vt(d),g=O(()=>(c.value,a.search(f.value))),p=W(!1),_=Lt("list-result"),w=W(0),I=O(()=>_.value?.children[w.value]);B(()=>s.show,M),B(u,v=>{v==="success"&&c.value&&a.addAll(c.value)}),B(f,()=>{w.value=0}),nt("mousemove",()=>p.value=!1),nt("keydown",()=>p.value=!0);async function M(v=!1){await Ot(),h.value?.focus(),v&&h.value?.select()}function F(v,m=!1){M(),!(v<0||v>=g.value?.length)&&(w.value=v,m&&(p.value=!0),I.value&&p.value&&I.value.scrollIntoView({block:"nearest"}))}function C(){I.value?.click()}return(v,m)=>{const yt=At,It=Dt,St=Gt,E=Wt;return b(),T(ot,null,[z(yt,{show:i.show,blur:"",onClick:m[0]||(m[0]=x=>y(n).toggle("search"))},null,8,["show"]),z(Bt,{name:"float-in"},{default:$(()=>[i.show?(b(),T("div",ue,[A("form",{class:"input",onSubmit:m[4]||(m[4]=J(()=>{},["prevent"]))},[z(It,{name:y(u)==="pending"?"line-md:loading-alt-loop":"ph:magnifying-glass-bold"},null,8,["name"]),Et(A("input",{ref_key:"searchInput",ref:h,"onUpdate:modelValue":m[1]||(m[1]=x=>Pt(l)?l.value=x:null),type:"search",incremental:"",class:"search-input",placeholder:"键入开始搜索",onKeydown:[m[2]||(m[2]=it(J(()=>{},["prevent"]),["up"])),m[3]||(m[3]=it(J(()=>{},["prevent"]),["down"]))]},null,544),[[jt,y(l)]])],32),z(Nt,{name:"expand"},{default:$(()=>[y(f)&&y(u)==="success"&&!y(g).length?(b(),T("div",ae," 无结果 ")):D("",!0),y(g).length?(b(),T("menu",{ref:"list-result",key:y(g).length<5?y(g).length:y(g)[0]?.id,class:"scrollcheck-y search-result"},[(b(!0),T(ot,null,$t(y(g),(x,et)=>(b(),lt(St,Rt({key:x.id},{ref_for:!0},x,{class:{active:y(w)===et},onMousemove:le=>F(et)}),null,16,["class","onMousemove"]))),128))])):D("",!0),y(g).length?(b(),T("div",{key:2,class:"tip",onClick:m[8]||(m[8]=x=>y(h)?.focus())},[z(E,{code:"ArrowUp",prevent:"",onPress:m[5]||(m[5]=x=>F(y(w)-1,!0))}),z(E,{code:"ArrowDown",prevent:"",onPress:m[6]||(m[6]=x=>F(y(w)+1,!0))}),m[9]||(m[9]=N(" 切换  ",-1)),z(E,{code:"Enter",icon:"",onPress:C}),m[10]||(m[10]=N(" 选择  ",-1)),z(E,{code:"Escape",icon:!1,onPress:m[7]||(m[7]=x=>y(n).toggle("search"))}),m[11]||(m[11]=N(" 关闭 ",-1))])):D("",!0)]),_:1})])):D("",!0)]),_:1})],64)}}}),ge=Object.assign(ht(de,[["__scopeId","data-v-f872f3fc"]]),{__name:"PopoverSearch"});export{ge as default};
