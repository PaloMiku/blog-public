import{k as w,Z as L,u as V,bv as q,O as z,bw as H,aD as U,e as W,q as S,z as j,y as x,r as A,G as M,t as G,s as I,K as T,bx as Z}from"./LivvtlNw.js";import{R as J,S as Q}from"./BEFc8N7m.js";const X={trailing:!0};function Y(a,e=25,i={}){if(i={...X,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let o,n,l=[],r,t;const b=(f,v)=>(r=$(a,f,v),r.finally(()=>{if(r=null,i.trailing&&t&&!n){const m=b(f,t);return t=null,m}}),r),y=function(...f){return i.trailing&&(t=f),r||new Promise(v=>{const m=!n&&i.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const u=i.leading?o:b(this,f);t=null;for(const d of l)d(u);l=[]},e),m?(o=b(this,f),v(o)):l.push(v)})},s=f=>{f&&(clearTimeout(f),n=null)};return y.isPending=()=>!!n,y.cancel=()=>{s(n),l=[],t=null},y.flush=()=>{if(s(n),!t||r)return;const f=t;return t=null,b(this,f)},y}async function $(a,e,i){return await a.apply(e,i)}function ra(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;K(a[0],a[1])&&a.unshift(e);let[i,o,n={}]=a,l=!1;const r=w(()=>L(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=V();n.server??=!0,n.default??=aa,n.getCachedData??=F,n.lazy??=!1,n.immediate??=!0,n.deep??=q.deep,n.dedupe??="cancel",n._functionName,t._asyncData[r.value];function b(){const u={cause:"initial",dedupe:n.dedupe};return t._asyncData[r.value]?._init||(u.cachedData=n.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=R(t,r.value,o,n,u.cachedData)),()=>t._asyncData[r.value].execute(u)}const y=b(),s=t._asyncData[r.value];s._deps++;const f=n.server!==!1&&t.payload.serverRendered;{let u=function(c){const _=t._asyncData[c];_?._deps&&(_._deps--,_._deps===0&&_?._off())};const d=z();if(d&&f&&n.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const c=d._nuxtOnBeforeMountCbs;H(()=>{c.forEach(_=>{_()}),c.splice(0,c.length)}),U(()=>c.splice(0,c.length))}const D=d&&(d._nuxtClientOnly||W(J,!1));f&&t.isHydrating&&(s.error.value||s.data.value!==void 0)?s.status.value=s.error.value?"error":"success":d&&(!D&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?d._nuxtOnBeforeMountCbs.push(y):n.immediate&&s.status.value!=="success"&&y();const h=x(),C=S(r,(c,_)=>{if((c||_)&&c!==_){l=!0;const P=t._asyncData[_]?.data.value!==void 0,N=t._asyncDataPromises[_]!==void 0,O={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[c]?._init){let E;_&&P?E=t._asyncData[_].data.value:(E=n.getCachedData(c,t,{cause:"initial"}),O.cachedData=E),t._asyncData[c]=R(t,c,o,n,E)}t._asyncData[c]._deps++,_&&u(_),(n.immediate||P||N)&&t._asyncData[c].execute(O),Z(()=>{l=!1})}},{flush:"sync"}),g=n.watch?S(n.watch,()=>{l||s._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};h&&j(()=>{C(),g(),u(r.value)})}const v={data:p(()=>t._asyncData[r.value]?.data),pending:p(()=>t._asyncData[r.value]?.pending),status:p(()=>t._asyncData[r.value]?.status),error:p(()=>t._asyncData[r.value]?.error),refresh:(...u)=>t._asyncData[r.value]?._init?t._asyncData[r.value].execute(...u):b()(),execute:(...u)=>v.refresh(...u),clear:()=>{const u=t._asyncData[r.value];if(u?._abortController)try{u._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{u._abortController=void 0}B(t,r.value)}},m=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>v);return Object.assign(m,v),m}function p(a){return w({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function K(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function B(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=T(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function k(a,e){const i={};for(const o of e)i[o]=a[o];return i}function R(a,e,i,o,n){a.payload._errors[e]??=void 0;const l=o.getCachedData!==F,r=i,t=o.deep?A:M,b=n!==void 0,y=a.hook("app:data:refresh",async f=>{(!f||f.includes(e))&&await s.execute({cause:"refresh:hook"})}),s={data:t(b?n:o.default()),pending:w(()=>s.status.value==="pending"),error:G(a.payload._errors,e),status:M("idle"),execute:(...f)=>{const[v,m=void 0]=f,u=v&&m===void 0&&typeof v=="object"?v:{};if(a._asyncDataPromises[e]&&(u.dedupe??o.dedupe)==="defer")return a._asyncDataPromises[e];{const D="cachedData"in u?u.cachedData:o.getCachedData(e,a,{cause:u.cause??"refresh:manual"});if(D!==void 0)return a.payload.data[e]=s.data.value=D,s.error.value=void 0,s.status.value="success",Promise.resolve(D)}s._abortController&&s._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),s._abortController=new AbortController,s.status.value="pending";const d=new Promise((D,h)=>{try{const C=u.timeout??o.timeout,g=ea([s._abortController?.signal,u?.signal],C);if(g.aborted){const c=g.reason;h(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"));return}return g.addEventListener("abort",()=>{const c=g.reason;h(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"))},{once:!0}),Promise.resolve(r(a,{signal:g})).then(D,h)}catch(C){h(C)}}).then(async D=>{let h=D;o.transform&&(h=await o.transform(D)),o.pick&&(h=k(h,o.pick)),a.payload.data[e]=h,s.data.value=h,s.error.value=void 0,s.status.value="success"}).catch(D=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==d)&&!s._abortController?.signal.aborted){if(typeof DOMException<"u"&&D instanceof DOMException&&D.name==="AbortError"){s.status.value="idle";return}s.error.value=Q(D),s.data.value=T(o.default()),s.status.value="error"}}).finally(()=>{delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=d,a._asyncDataPromises[e]},_execute:Y((...f)=>s.execute(...f),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{y(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),l||I(()=>{a._asyncData[e]?._init||(B(a,e),s.execute=()=>Promise.resolve())})}};return s}const aa=()=>{},F=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function ea(a,e){const i=a.filter(l=>!!l);if(typeof e=="number"&&e>=0){const l=AbortSignal.timeout?.(e);l&&i.push(l)}if(AbortSignal.any)return AbortSignal.any(i);const o=new AbortController;for(const l of i)if(l.aborted){const r=l.reason??new DOMException("Aborted","AbortError");try{o.abort(r)}catch{o.abort()}return o.signal}const n=()=>{const r=i.find(t=>t.aborted)?.reason??new DOMException("Aborted","AbortError");try{o.abort(r)}catch{o.abort()}};for(const l of i)l.addEventListener?.("abort",n,{once:!0});return o.signal}export{ra as u};
