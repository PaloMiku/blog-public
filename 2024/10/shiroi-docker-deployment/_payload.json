[{"data":1,"prerenderedAt":275},["ShallowReactive",2],{"/2024/10/shiroi-docker-deployment":3,"surround-/2024/10/shiroi-docker-deployment":264},{"id":4,"title":5,"body":6,"categories":240,"date":242,"description":243,"draft":244,"extension":245,"image":246,"meta":247,"navigation":248,"path":249,"permalink":250,"readingTime":251,"recommend":232,"references":250,"seo":256,"sitemap":257,"stem":258,"tags":259,"type":250,"updated":262,"__hash__":263},"content/posts/2024/10/shiroi-docker-deployment.md","GitHub Action 构建 Shiroi Docker 镜像",{"type":7,"value":8,"toc":231},"minimark",[9,13,17,20,23,26,29,53,56,59,62,65,68,75,78,81,84,87,98,105,112,126,135,141,157,167,170,176,179,190,193,196,204,207,210,216,222,225,228],[10,11,12],"h2",{"id":12},"前言",[14,15,16],"p",{},"Mix-Space 是一个前后端分离的博客系统，你可以将前端和后端分别部署在不同的位置。此前，你可以将前端部署在 Vercel 云函数上，以缓解服务器压力并提升访问速度。",[14,18,19],{},"但随着 Vercel 调整 Hobby 免费套餐的额度，免费额度已越来越不够用。此时，我们可以通过 Docker 将 Shiro 部署到自己的服务器上来解决问题。然而，在使用 Shiroi（Shiro 的闭源捐赠版）时，原作者 innei 并未提供可用的 Docker 镜像。",[14,21,22],{},"这意味着你需要在自己的服务器上构建 Shiroi，但对于配置较低（低于 2G 内存）的云服务器来说，这很困难，基本会导致服务器爆内存假死。",[14,24,25],{},"Innei 给出的解决方案是使用 Github Action 完成构建，并将构建产物直接推送到你的服务器上，从而减轻服务器压力。",[14,27,28],{},"不过，这个方案在我看来有以下局限性：",[30,31,32],"card-list",{},[33,34,35,39,47,50],"ul",{},[36,37,38],"li",{},"需要在服务器安装相关依赖：Node.js、PM2、Sharp，但部分用户（比如我）使用的是 1Panel 管理服务器，不希望安装额外依赖",[36,40,41,42,46],{},"输出目录被固定在服务器的 ",[43,44,45],"code",{"code":45},"root"," 目录，不易更改",[36,48,49],{},"需要在 Github 仓库存储服务器登录信息，如 SSH 密钥等",[36,51,52],{},"项目本身有回滚功能，但一般用户可能不需要，也会占用大量服务器空间",[14,54,55],{},"总之，我并不想折腾这套方案。那么，有没有更好的办法？",[14,57,58],{},"欸，你说 Docker 部署不就行了？虽然 Innei 没给 Docker 镜像，但我们可以自己造！",[10,60,61],{"id":61},"思路",[14,63,64],{},"我们当然不能直接在自己的服务器上构建镜像，构建 Docker 镜像的资源占用并不会比直接构建站点静态文件少。",[14,66,67],{},"那我们可以借鉴 innei 的思路，用 Github Action 进行 Docker 镜像构建，不就可以了吗？",[14,69,70,71,74],{},"但仅仅构建还不够，还需要有地方存放镜像。我也不想用直接推送到服务器的办法，这同样需要在 Github 存储服务器登录信息。虽然用 ",[43,72,73],{"code":73},"secret"," 存储理论上安全，但谁能保证呢？",[14,76,77],{},"而且部分用户的服务器在国内，Github Action 主动推送的速度也未必理想。",[10,79,80],{"id":80},"选择",[14,82,83],{},"最终，我选择用 Github Action 构建镜像，然后上传到 Github Packages。Github Packages 默认会对私有库镜像进行私有保护，保障镜像不会泄露。",[14,85,86],{},"Docker 对镜像仓库的管理分为 3 个层级：命名空间（namespace）、镜像仓库（repository）、标签（tag）：",[33,88,89,92,95],{},[36,90,91],{},"命名空间以名称为标识，一个命名空间可管理多个镜像仓库",[36,93,94],{},"镜像仓库通过名称标识，一个仓库可保存一个镜像的多个版本",[36,96,97],{},"镜像版本通过标签区分",[14,99,100,101,104],{},"基于以上层级关系，一个完整的镜像路径 ",[43,102,103],{"code":103},"{namespace}/{repository}:{tag}"," 可以唯一确定一个镜像。",[14,106,107,108,111],{},"新建一个私有库，并在 ",[43,109,110],{"code":110},".github/workflows"," 目录下新建 yml 工作流文件，填入如下内容：",[113,114,116,123],"alert",{"type":115},"warning",[117,118,120],"template",{"v-slot:title":119},"",[14,121,122],{},"请注意新建的仓库权限，一定要为私有仓库！",[14,124,125],{},"若为公开仓库则所有人都可下载本镜像。",[127,128,133],"pre",{"className":129,"code":131,"language":132,"meta":119},[130],"language-yaml","name: Docker Build\n\non:\n  push:\n    branches:\n      - main\n  schedule:\n    - cron: '0 3 * * *'\n\n  repository_dispatch:\n    types: [trigger-workflow]\n\npermissions: write-all\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  PNPM_VERSION: 9.x.x\n  HASH_FILE: build_hash\n\njobs:\n  prepare:\n    name: Prepare\n    runs-on: ubuntu-latest\n    if: ${{ github.event.head_commit.message != 'Update hash file' }}\n\n    outputs:\n      hash_content: ${{ steps.read_hash.outputs.hash_content }}\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Read HASH_FILE content\n        id: read_hash\n        run: |\n          content=$(cat ${{ env.HASH_FILE }}) || true\n          echo \"hash_content=$content\" >> \"$GITHUB_OUTPUT\"\n  check:\n    name: Check Should Rebuild\n    runs-on: ubuntu-latest\n    needs: prepare\n    outputs:\n      canceled: ${{ steps.use_content.outputs.canceled }}\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: innei-dev/shiroi\n          token: ${{ secrets.GH_PAT }}\n          fetch-depth: 0\n          lfs: true\n\n      - name: Use content from prev job and compare\n        id: use_content\n        env:\n          FILE_HASH: ${{ needs.prepare.outputs.hash_content }}\n        run: |\n          file_hash=$FILE_HASH\n          current_hash=$(git rev-parse --short HEAD)\n          echo \"File Hash: $file_hash\"\n          echo \"Current Git Hash: $current_hash\"\n          if [ \"$file_hash\" == \"$current_hash\" ]; then\n            echo \"Hashes match. Stopping workflow.\"\n            echo \"canceled=true\" >> $GITHUB_OUTPUT\n          else\n            echo \"Hashes do not match. Continuing workflow.\"\n          fi\n\n  build:\n    name: Build artifact\n    runs-on: ubuntu-latest\n    needs: check\n    if: ${{needs.check.outputs.canceled != 'true'}}\n\n    outputs:\n      sha_short: ${{ steps.store.outputs.sha_short }}\n      branch: ${{ steps.store.outputs.branch }}\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: innei-dev/shiroi\n          token: ${{ secrets.GH_PAT }}\n          fetch-depth: 0\n          lfs: true\n\n      - name: Login to Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build Docker Image\n        run: |\n          docker build -t ghcr.io/${{ secrets.DOCKER_NAMESPACE }}/shiroi:latest .\n\n      - name: Push Docker Image to Github\n        run: |\n          docker push ghcr.io/${{ secrets.DOCKER_NAMESPACE }}/shiroi:latest\n\n      - name: Store artifact commit version\n        shell: bash\n        id: store\n        run: |\n          sha_short=$(git rev-parse --short HEAD)\n          branch_name=$(git rev-parse --abbrev-ref HEAD)\n          echo \"sha_short=$sha_short\" >> \"$GITHUB_OUTPUT\"\n          echo \"branch=$branch_name\" >> \"$GITHUB_OUTPUT\"\n  store:\n    name: Store artifact commit version\n    runs-on: ubuntu-latest\n    needs: [build]\n    steps:\n\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          persist-credentials: false\n          fetch-depth: 0\n\n      - name: Use outputs from build\n        env:\n          SHA_SHORT: ${{ needs.build.outputs.sha_short }}\n          BRANCH: ${{ needs.build.outputs.branch }}\n        run: |\n          echo \"SHA Short from build: $SHA_SHORT\"\n          echo \"Branch from build: $BRANCH\"\n\n      - name: Write hash to file\n        env:\n          SHA_SHORT: ${{ needs.build.outputs.sha_short }}\n\n        run: |\n          echo \"SHA_SHORT: $SHA_SHORT\"\n          echo $SHA_SHORT > ${{ env.HASH_FILE }}\n\n      - name: Commit files\n        run: |\n          git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n          git config --local user.name \"github-actions[bot]\"\n          git add ${{ env.HASH_FILE }}\n          git status\n          git commit -a -m \"Update hash file\"\n\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: ${{ github.ref }}\n","yaml",[43,134,131],{"__ignoreMap":119},[14,136,137,138,140],{},"这样就可以实现简单的构建并上传 Github Registry 镜像。你需要在仓库的 ",[43,139,73],{"code":73}," 设置中配置以下机密变量：",[30,142,143],{},[33,144,145,151],{},[36,146,147,150],{},[43,148,149],{"code":149},"GH_PAT","：有权限访问 Shiroi 仓库的 Github Access Token",[36,152,153,156],{},[43,154,155],{"code":155},"DOCKER_NAMESPACE","：镜像命名空间，全部小写，建议用个人 Github 用户名",[113,158,159,164],{},[117,160,161],{"v-slot:title":119},[14,162,163],{},"注意！",[14,165,166],{},"由于 Github Action 的限制，仓库 3 个月无活动时，工作流会被禁用。\n@innei",[14,168,169],{},"我们采用 innei 的办法，每次构建结束后上传一个存储哈希值的文件，保持仓库活跃。同时，构建前对仓库哈希值进行对比，避免重复构建。",[14,171,172,173,175],{},"参考上述修改环境 ",[43,174,73],{"code":73}," 后，运行工作流（注意先开启仓库设置中 Github Action 写入文件的权限），即可生成哈希值文件并构建镜像。",[10,177,178],{"id":178},"使用",[14,180,181,182,185,186,189],{},"保存工作流文件，等待运行完毕后，你应该可以在仓库侧边栏的 ",[43,183,184],{"code":184},"Packages"," 或个人 Github 主页的 ",[43,187,188],{"code":188},"Package"," 里找到镜像文件。",[14,191,192],{},"在服务器上拉取镜像前，需要先配置 Docker 私有仓库。注意，Gitea 实例必须为 HTTPS 地址，否则 Docker 会拒绝拉取不安全的私有仓库。",[14,194,195],{},"在服务器上输入以下指令登录 Github Registry 私有仓库：",[127,197,202],{"className":198,"code":200,"language":201,"meta":119},[199],"language-bash","docker login ghcr.io\n","bash",[43,203,200],{"__ignoreMap":119},[14,205,206],{},"输入账号和有访问权限的 Github Access Token，确认登录后即可拉取私有仓库镜像。如果你用的是 1Panel，可以在容器仓库设置中直接配置私有仓库。",[14,208,209],{},"你也可以用如下 compose 文件配置安装 Shiroi：",[127,211,214],{"className":212,"code":213,"language":132,"meta":119},[130],"services:\n  shiro:\n    container_name: Shiroi\n    image:\n    restart: always\n    environment:\n      - NEXT_SHARP_PATH=/usr/local/lib/node_modules/sharp\n      - NEXT_PUBLIC_API_URL=https://api.example.com/api/v2\n      - NEXT_PUBLIC_GATEWAY_URL=https://api.example.com\n    ports:\n      - 127.0.0.1:2323:2323\n    networks:\n      - mx-network\n",[43,215,213],{"__ignoreMap":119},[14,217,218,221],{},[43,219,220],{"code":220},"image"," 填写你在软件包仓库看到的容器镜像信息。",[10,223,224],{"id":224},"后话",[14,226,227],{},"这样你就算是简单完成了，本文本质上偏专业系，而非喂饭文。",[14,229,230],{},"如有疑问，欢迎在评论区提问或结合搜索引擎查阅本文。",{"title":119,"searchDepth":232,"depth":232,"links":233},4,[234,236,237,238,239],{"id":12,"depth":235,"text":12},2,{"id":61,"depth":235,"text":61},{"id":80,"depth":235,"text":80},{"id":178,"depth":235,"text":178},{"id":224,"depth":235,"text":224},[241],"技术探索","2024-10-21 19:24:26","本文介绍了如何利用 GitHub Actions 为 Mix-Space 的闭源前端 Shiroi 构建 Docker 镜像并推送至 GitHub Packages，解决低配服务器本地构建内存不足的问题。本文记录了完整 Workflow 配置，包括定时触发、哈希去重、登录 ghcr.io、构建与推送 latest 镜像等关键步骤，并说明在 1Panel 或命令行拉取私有镜像的方法。本文分享了避免在服务器安装 Node、PM2 等依赖、无需暴露 SSH 密钥即可实现安全拉取与更新的实践经验，适合希望将 Shiroi 容器化部署到个人服务器的用户。",false,"md","https://mx-space.js.org/assets/images/preview/shiro.png",{},true,"/2024/10/shiroi-docker-deployment",null,{"text":252,"minutes":253,"time":254,"words":255},"9 min read",8.275,496500,1655,{"title":5,"description":243},{"loc":249},"posts/2024/10/shiroi-docker-deployment",[260,261],"Mix-Space","Docker","2025-06-02 22:00:00","1EEHY8b9MPgKVgQ9oBDAt6GtGW6jpF_uUnmsqk3Hjqk",[265,270],{"title":266,"path":267,"stem":268,"date":269,"type":250,"children":-1},"编写1Panel应用商店第三方程序","/2024/10/write-1panel-app","posts/2024/10/write-1panel-app","2024-10-17 19:24:26",{"title":271,"path":272,"stem":273,"date":274,"type":250,"children":-1},"破坏型迁移：站点反复横跳与稳定工作","/2024/12/break-change-2024","posts/2024/12/break-change-2024","2024-12-07 18:24:26",1761052954567]