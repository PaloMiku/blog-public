[{"data":1,"prerenderedAt":380},["ShallowReactive",2],{"/2024/10/shiroi-docker-deployment":3,"surround-/2024/10/shiroi-docker-deployment":371},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"date":10,"categories":11,"tags":13,"readingTime":16,"body":21,"_type":364,"_id":365,"_source":366,"_file":367,"_stem":368,"_extension":369,"_original_dir":370},"/2024/10/shiroi-docker-deployment","10",false,"","GitHub Action构建Shiroi Docker镜像","Mix-Space，它属于前后端分离博客系统，你可以把前端和后端分离部署在不同的地方，在之前你可以把前端部署在Vercel云函数上，达到缓解服务器压力和提升访问速度的效果。","2024-10-21T11:24:26.000Z",[12],"技术探索",[14,15],"Mix-Space","Docker",{"text":17,"minutes":18,"time":19,"words":20},"10 min read",9.31,558600,1862,{"type":22,"children":23,"toc":355},"root",[24,32,37,42,47,52,57,90,95,100,105,110,115,128,133,138,143,148,166,179,192,201,213,238,247,252,264,269,290,295,300,308,313,318,326,337,345,350],{"type":25,"tag":26,"props":27,"children":29},"element","h2",{"id":28},"前言",[30],{"type":31,"value":28},"text",{"type":25,"tag":33,"props":34,"children":35},"p",{},[36],{"type":31,"value":9},{"type":25,"tag":33,"props":38,"children":39},{},[40],{"type":31,"value":41},"但是随着Vercel调整Hobby免费套餐的额度，Vercel免费套餐已经越来越不够用了，这个时候我们可以通过Docker将Shiro部署到自己的服务器上来解决问题，但是我在使用Shiroi（Shiro的闭源捐赠版）的时候遇到了问题：原作者innei并没有提供它的可用Docker镜像。",{"type":25,"tag":33,"props":43,"children":44},{},[45],{"type":31,"value":46},"这样的话你就需要在自己服务器上对Shiroi进行构建，但是对于配置较低（低于2G内存）的云服务器来说这是比较困难的，基本上会导致服务器爆内存假死。",{"type":25,"tag":33,"props":48,"children":49},{},[50],{"type":31,"value":51},"Innei给出的解决方案是使用Github Action完成构建，将构建后的产物直接推送到你的服务器上，达到缓解服务器压力的作用。",{"type":25,"tag":33,"props":53,"children":54},{},[55],{"type":31,"value":56},"但是这个方案在我看来存在以下局限性：",{"type":25,"tag":58,"props":59,"children":60},"ul",{},[61,67,80,85],{"type":25,"tag":62,"props":63,"children":64},"li",{},[65],{"type":31,"value":66},"需要你在服务器安装相关依赖：Node.js，PM2，Sharp，但是部分用户（比如我）使用的是1Panel管理服务器，不大想要在服务器安装额外依赖。",{"type":25,"tag":62,"props":68,"children":69},{},[70,72,78],{"type":31,"value":71},"输出目录被固定在了服务器的",{"type":25,"tag":73,"props":74,"children":76},"code",{"className":75},[],[77],{"type":31,"value":22},{"type":31,"value":79},"目录，不好更改。",{"type":25,"tag":62,"props":81,"children":82},{},[83],{"type":31,"value":84},"你需要向GitHub仓库存储你的服务器登录信息，比如SSH密钥等。",{"type":25,"tag":62,"props":86,"children":87},{},[88],{"type":31,"value":89},"项目本身有回滚功能，但一般用户可能不需要此功能，也会占用大量的服务器空间。",{"type":25,"tag":33,"props":91,"children":92},{},[93],{"type":31,"value":94},"总之我是不大想要折腾这套方案，那么有啥更好的办法嘛？",{"type":25,"tag":33,"props":96,"children":97},{},[98],{"type":31,"value":99},"欸，你说Docker部署不就行了，虽然Innei没给你Docker镜像，但是我们可以自己造啊！",{"type":25,"tag":26,"props":101,"children":103},{"id":102},"思路",[104],{"type":31,"value":102},{"type":25,"tag":33,"props":106,"children":107},{},[108],{"type":31,"value":109},"我们当然不能直接在自己服务器上构建镜像，构建Docker镜像产生的资源占用并不会比直接构建站点静态文件要少。",{"type":25,"tag":33,"props":111,"children":112},{},[113],{"type":31,"value":114},"那我们可以把innei的思路拿过来用一下，用Github Action进行Docker镜像构建不就可以了？",{"type":25,"tag":33,"props":116,"children":117},{},[118,120,126],{"type":31,"value":119},"但是光构建也不行，你还需要找个地方把镜像放下来，而我也不想使用直接推送服务器的办法，这也需要在Github这里存储服务器登录信息，虽然是",{"type":25,"tag":73,"props":121,"children":123},{"className":122},[],[124],{"type":31,"value":125},"secret",{"type":31,"value":127},"存储应该能保证安全性，但是谁又能说准这个事情呢？",{"type":25,"tag":33,"props":129,"children":130},{},[131],{"type":31,"value":132},"而且部分用户服务器在国内，Github Action的主动推送速度也不见得一定多好。",{"type":25,"tag":26,"props":134,"children":136},{"id":135},"选择",[137],{"type":31,"value":135},{"type":25,"tag":33,"props":139,"children":140},{},[141],{"type":31,"value":142},"最后我的选择方案是使用Github Action进行构建，然后将镜像传到Github Packages，Github Packages默认会对私有库镜像进行私有，也保障镜像不会直接泄露。",{"type":25,"tag":33,"props":144,"children":145},{},[146],{"type":31,"value":147},"Docker 对镜像仓库的管理共分为 3 个层级，依次是命名空间 (namespace) 、镜像仓库 (repository) 和 标签 (tag)：",{"type":25,"tag":58,"props":149,"children":150},{},[151,156,161],{"type":25,"tag":62,"props":152,"children":153},{},[154],{"type":31,"value":155},"命名空间以名称作为标识，一个命名空间可管理多个镜像仓库。",{"type":25,"tag":62,"props":157,"children":158},{},[159],{"type":31,"value":160},"镜像仓库通过名称标识，一个镜像仓库中可保存一个镜像（image）的多个版本。",{"type":25,"tag":62,"props":162,"children":163},{},[164],{"type":31,"value":165},"镜像版本通过标签进行区分。",{"type":25,"tag":33,"props":167,"children":168},{},[169,171,177],{"type":31,"value":170},"基于以上层级关系，一个完整的镜像路径 ",{"type":25,"tag":73,"props":172,"children":174},{"className":173},[],[175],{"type":31,"value":176},"{namespace}/{repository}:{tag}",{"type":31,"value":178}," 可以唯一确定一个镜像。",{"type":25,"tag":33,"props":180,"children":181},{},[182,184,190],{"type":31,"value":183},"新建一个私有库（注意一定是私有仓库）并在",{"type":25,"tag":73,"props":185,"children":187},{"className":186},[],[188],{"type":31,"value":189},".github/workflows",{"type":31,"value":191},"目录下新建yml工作流文件，填入如下内容：",{"type":25,"tag":193,"props":194,"children":196},"pre",{"code":195},"name: Docker\n\non:\n  push:\n    branches:\n      - main\n  schedule:\n     - cron: '0 3 * * *'\n\n  repository_dispatch:\n    types: [trigger-workflow]\n\npermissions: write-all\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  PNPM_VERSION: 9.x.x\n  HASH_FILE: build_hash\n\njobs:\n  prepare:\n    name: Prepare\n    runs-on: ubuntu-latest\n    if: ${{ github.event.head_commit.message != 'Update hash file' }}\n\n    outputs:\n      hash_content: ${{ steps.read_hash.outputs.hash_content }}\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Read HASH_FILE content\n        id: read_hash\n        run: |\n          content=$(cat ${{ env.HASH_FILE }}) || true\n          echo \"hash_content=$content\" >> \"$GITHUB_OUTPUT\"\n  check:\n    name: Check Should Rebuild\n    runs-on: ubuntu-latest\n    needs: prepare\n    outputs:\n      canceled: ${{ steps.use_content.outputs.canceled }}\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: innei-dev/shiroi\n          token: ${{ secrets.GH_PAT }}\n          fetch-depth: 0\n          lfs: true\n\n      - name: Use content from prev job and compare\n        id: use_content\n        env:\n          FILE_HASH: ${{ needs.prepare.outputs.hash_content }}\n        run: |\n          file_hash=$FILE_HASH\n          current_hash=$(git rev-parse --short HEAD)\n          echo \"File Hash: $file_hash\"\n          echo \"Current Git Hash: $current_hash\"\n          if [ \"$file_hash\" == \"$current_hash\" ]; then\n            echo \"Hashes match. Stopping workflow.\"\n            echo \"canceled=true\" >> $GITHUB_OUTPUT\n          else\n            echo \"Hashes do not match. Continuing workflow.\"\n          fi\n\n  build:\n    name: Build artifact\n    runs-on: ubuntu-latest\n    needs: check\n    if: ${{needs.check.outputs.canceled != 'true'}}\n\n    outputs:\n      sha_short: ${{ steps.store.outputs.sha_short }}\n      branch: ${{ steps.store.outputs.branch }}\n\n    steps:\n    - uses: actions/checkout@v4\n      with:\n        repository: innei-dev/shiroi\n        token: ${{ secrets.GH_PAT }}\n        fetch-depth: 0\n        lfs: true\n\n    - name: Login to Registry\n      uses: docker/login-action@v3\n      with:\n        registry: ghcr.io\n        username: ${{ github.actor }}\n        password: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Build Docker Image\n      run: |\n        docker build -t ghcr.io/${{ secrets.DOCKER_NAMESPACE }}/shiroi:latest .\n\n    - name: Push Docker Image to Github\n      run: |\n        docker push ghcr.io/${{ secrets.DOCKER_NAMESPACE }}/shiroi:latest\n\n    - name: Store artifact commit version\n      shell: bash\n      id: store\n      run: |\n        sha_short=$(git rev-parse --short HEAD)\n        branch_name=$(git rev-parse --abbrev-ref HEAD)\n        echo \"sha_short=$sha_short\" >> \"$GITHUB_OUTPUT\"\n        echo \"branch=$branch_name\" >> \"$GITHUB_OUTPUT\"\n  store:\n    name: Store artifact commit version\n    runs-on: ubuntu-latest\n    needs: [build]\n    steps:\n\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          persist-credentials: false\n          fetch-depth: 0\n\n      - name: Use outputs from build\n        env:\n          SHA_SHORT: ${{ needs.build.outputs.sha_short }}\n          BRANCH: ${{ needs.build.outputs.branch }}\n        run: |\n          echo \"SHA Short from build: $SHA_SHORT\"\n          echo \"Branch from build: $BRANCH\"\n      - name: Write hash to file\n        env:\n          SHA_SHORT: ${{ needs.build.outputs.sha_short }}\n\n        run: |\n          echo \"SHA_SHORT: $SHA_SHORT\"\n          echo $SHA_SHORT > ${{ env.HASH_FILE }}\n      - name: Commit files\n        run: |\n          git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n          git config --local user.name \"github-actions[bot]\"\n          git add ${{ env.HASH_FILE }}\n          git status\n          git commit -a -m \"Update hash file\"\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: ${{ github.ref }}\n",[197],{"type":25,"tag":73,"props":198,"children":199},{"__ignoreMap":7},[200],{"type":31,"value":195},{"type":25,"tag":33,"props":202,"children":203},{},[204,206,211],{"type":31,"value":205},"这样就可以实现简单的构建并上传Github Registry镜像，需要你在仓库的",{"type":25,"tag":73,"props":207,"children":209},{"className":208},[],[210],{"type":31,"value":125},{"type":31,"value":212},"设置中配置一个机密变量：",{"type":25,"tag":58,"props":214,"children":215},{},[216,227],{"type":25,"tag":62,"props":217,"children":218},{},[219,225],{"type":25,"tag":73,"props":220,"children":222},{"className":221},[],[223],{"type":31,"value":224},"GH_PAT",{"type":31,"value":226},"：有权限访问Shiroi仓库的Github Access Token。",{"type":25,"tag":62,"props":228,"children":229},{},[230,236],{"type":25,"tag":73,"props":231,"children":233},{"className":232},[],[234],{"type":31,"value":235},"DOCKER_NAMESPACE",{"type":31,"value":237},"：镜像的命名空间，其中不要有任何大写字符，为了好记和防冲突可能性尽量选择使用个人Github用户名的小写字符。",{"type":25,"tag":239,"props":240,"children":241},"blockquote",{},[242],{"type":25,"tag":33,"props":243,"children":244},{},[245],{"type":31,"value":246},"由于 GitHub action 的限制，当一个仓库在 3 个月内没有活动时，工作流会被禁用。\n@innei",{"type":25,"tag":33,"props":248,"children":249},{},[250],{"type":31,"value":251},"所以我们采用innei的办法，每次构建结束后上传一个存储哈希值的文件，来保持仓库活动，而且在构建前对仓库哈希值进行对比，也不会出现重复构建的情况。",{"type":25,"tag":33,"props":253,"children":254},{},[255,257,262],{"type":31,"value":256},"参考上面修改环境",{"type":25,"tag":73,"props":258,"children":260},{"className":259},[],[261],{"type":31,"value":125},{"type":31,"value":263},"后，运行工作流（注意先开启你仓库设置中Github Action写入文件的权限），这样就会生成哈希值文件并且构建镜像了。",{"type":25,"tag":26,"props":265,"children":267},{"id":266},"使用",[268],{"type":31,"value":266},{"type":25,"tag":33,"props":270,"children":271},{},[272,274,280,282,288],{"type":31,"value":273},"保存工作流文件，等待运行完毕，你应该可以在仓库侧边",{"type":25,"tag":73,"props":275,"children":277},{"className":276},[],[278],{"type":31,"value":279},"Packages",{"type":31,"value":281},"或者个人Github账号主页的",{"type":25,"tag":73,"props":283,"children":285},{"className":284},[],[286],{"type":31,"value":287},"Package",{"type":31,"value":289},"里找到镜像文件。",{"type":25,"tag":33,"props":291,"children":292},{},[293],{"type":31,"value":294},"在你个人服务器上拉取镜像前，你需要先在你的服务器上配置Docker私有仓库，值得注意的是你的Gitea实例必须是HTTPS地址，不然Docker会拒绝拉取不安全的私有仓库。",{"type":25,"tag":33,"props":296,"children":297},{},[298],{"type":31,"value":299},"在你的服务器上输入以下指令登录Github Resgistry私有仓库",{"type":25,"tag":193,"props":301,"children":303},{"code":302},"docker login ghcr.io\n",[304],{"type":25,"tag":73,"props":305,"children":306},{"__ignoreMap":7},[307],{"type":31,"value":302},{"type":25,"tag":33,"props":309,"children":310},{},[311],{"type":31,"value":312},"然后会提示你输入账号和有访问权限的Github Access Token，确认登录后你就可以拉取你的私有仓库镜像了，如果你是使用的1Panel的话，可以在容器的仓库设置直接设置私有仓库。",{"type":25,"tag":33,"props":314,"children":315},{},[316],{"type":31,"value":317},"然后你也可以使用下面的compose文件进行配置安装Shiroi：",{"type":25,"tag":193,"props":319,"children":321},{"code":320},"services:\n  shiro:\n    container_name: Shiroi\n    image:\n    restart: always\n    environment:\n      - NEXT_SHARP_PATH=/usr/local/lib/node_modules/sharp\n      - NEXT_PUBLIC_API_URL=https://api.example.com/api/v2\n      - NEXT_PUBLIC_GATEWAY_URL=https://api.example.com\n    ports:\n      - 127.0.0.1:2323:2323\n    networks:\n      - 1panel-network\nnetworks:\n  1panel-network:\n    external: true\n",[322],{"type":25,"tag":73,"props":323,"children":324},{"__ignoreMap":7},[325],{"type":31,"value":320},{"type":25,"tag":33,"props":327,"children":328},{},[329,335],{"type":25,"tag":73,"props":330,"children":332},{"className":331},[],[333],{"type":31,"value":334},"image",{"type":31,"value":336},"这里填写你在软件包仓库这里看到的容器镜像信息，当然这是适用于1Panel的，常规部署也可以用下面这个",{"type":25,"tag":193,"props":338,"children":340},{"code":339},"services:\n  shiro:\n    container_name: Shiroi\n    image:\n    restart: always\n    environment:\n      - NEXT_SHARP_PATH=/usr/local/lib/node_modules/sharp\n      - NEXT_PUBLIC_API_URL=https://api.example.com/api/v2\n      - NEXT_PUBLIC_GATEWAY_URL=https://api.example.com\n    ports:\n      - 127.0.0.1:2323:2323\n    networks:\n      - mx-network\n",[341],{"type":25,"tag":73,"props":342,"children":343},{"__ignoreMap":7},[344],{"type":31,"value":339},{"type":25,"tag":26,"props":346,"children":348},{"id":347},"后话",[349],{"type":31,"value":347},{"type":25,"tag":33,"props":351,"children":352},{},[353],{"type":31,"value":354},"这样你就算是简单完成了，本文本质上偏专业系，而非喂饭文，如果有疑问可以评论区提问或者搭配搜索引擎食用本文。",{"title":7,"searchDepth":356,"depth":356,"links":357},4,[358,360,361,362,363],{"id":28,"depth":359,"text":28},2,{"id":102,"depth":359,"text":102},{"id":135,"depth":359,"text":135},{"id":266,"depth":359,"text":266},{"id":347,"depth":359,"text":347},"markdown","content:posts:2024:10:shiroi-docker-deployment.md","content","posts/2024/10/shiroi-docker-deployment.md","posts/2024/10/shiroi-docker-deployment","md","/posts",[372,376],{"_path":373,"title":374,"date":375},"/2024/10/write-1panel-app","编写1Panel应用商店第三方程序","2024-10-17T11:24:26.000Z",{"_path":377,"title":378,"date":379},"/2024/12/break-change-2024","破坏型迁移：站点反复横跳与稳定工作","2024-12-07T10:24:26.000Z",1748468051051]